#include <stddef.h>
#include "../includes/interpretator.h"

/** Ссылка на текущий фрейм */
Frame *currentFrame = NULL;
/** Флаг процессиногового останова */
bool pStop = FALSE;
/** Флаг препрцессингового останова */
bool ppStop = FALSE;

void INTERPRETATOR_Preprocess() {
    while (ppStop == FALSE) {
        pStop = FALSE;
        INTERPRETATOR_Process();
    }
}

void INTERPRETATOR_Process() {
    while (pStop == FALSE) {

        //Если указатель инструкции текущего фрейма указывает в никуда, завершить работу процессора и препроцессора.
        //Данная ситуация возможна только на этапе инициализации вм, когда метод clinit пуст, его фрейм не создается
        //и в качестве текущего фрейма остается стартовый фрейм с указателем инструкции (cia) равным NULL. Так как
        //после статртового clinit при инициализации должен быть программно вызван main, неободимо полностью прекратить
        //работу интерпретатора и передать управление обратно в инициализатор.
        if (currentFrame->cia == NULL) {
            ppStop = TRUE;
            return;
        }
    }
}

/**
 * Возаращает перечень типов аргументов метода в буфер. Каждый элемент в буфере
 * представляет собой значение типа.
 *
 * @param буефер для записи перечня типов аргументов
 * @param sig сигнатура метода
 */
uint8_t INTERPRETATOR_GetMethodArgs(char * sig, int8_t* bf) {
    return 0;
    //Пока он ничего не возвращает, просто выкидывает назад 0 - нет аргументов.
}

/**
 * Возвращает тип возвращаемого значения метода по его сигнатуре
 *
 * @param sig сигнатура метода
 */
uint8_t INTERPRETATOR_GetMethodRetType(char * sig) {
    return TYPE_VOID;
    //Пока он возвращает только VOID.
}


/**
 * Дествие: Создает новый объект
 * Результат: 1. Размещение на OS ссылки на объект типа aref
 *            2. Размешение на osOut ссылки на объект типа aref
 * Механика: В нормальном режиме получает в качестве аргумена адрес
 *           значения в CP с определение создаваемого объекта а с вершины
 *           стека TID, в котором необходимо создать эземлпяр.
 *           Работа разделяется на четыре режма:
 *
 *           1. Если оба аргумента являются положительными значениями.
 *           Получив данные значения, задействует загрузчик в части функции
 *           Load которая в реузльтате свой работы вернет вернет aref,
 *           который помещается на вершину OS.
 *
 *           2. Если в качестве TID будет получено значение
 *           -2. То интрукция сначала создаст новый поток а затем
 *           произведет действия описаные в п.1 относительно созданнного
 *           потока.
 *
 *           3. Если в качестве TID будет получено значение
 *           -1. То интрукция создаст объект в текущем потоке
 *
 *           4. Если в качетсве указателя на CP указано отрицательно значение,
 *           задействует режим первичной загрузки класса. В данным режиме,
 *           создаст новый поток, и передст загрузчику в качестве пути
 *           загрузки FDP. Получив aref, заносит его в массив вывода osOut,
 *           для  возможности деальнешего считывания переферией вм.
 *
 * @param cpPointer указатель определения класса в CP
 */
void INTERPRETATOR_Exec_New(uint32_t *cpPointer) {


    /*
      1. Делаем эту инструкция (переделка Load загрузчика
      2. Провряем ее работу (корректируем иннициализатор)
      4. Релизовать метод bipush
      3. Делаем инутрукцию invokeseptial
      6. Делаем инструкцию invokevirtal
     */
}

/**
 * Действе: Вызывает специальный метод объекта. К специальным методам относятся
 *          - методы суперкласса, конструкторы (включая статический
 *          инициализатор) и приватные методы.
 * Результат: Создание нового фрейма, переиницилазиация интерпретатора и передача
 *            управления в целевой метод
 * Входные данные: 1. Стек - Ссылка на объект (aref) в котором будет вызван метод.
 *                 2. Первый аргумент - адрес определения метода в пуле методов.
 * Механика:
 *
 * @param adr
 */
void INTERPRETATOR_Exec_Invokespetial(uint32_t adr) {
    char *fdp = HEAP_GetClass(currentFrame->cRef)->fdp;
    int16_t sigSize;
    int *mAddr = (int*) malloc(4);
    FSS_ReadShort(&sigSize, fdp, adr);
    FSS_ReadInt32(mAddr, fdp, adr + (uint32_t) sigSize + 2);
    char *sig = malloc(sizeof(char) * sigSize);
    FSS_ReadBytes(sig, fdp, adr + 2, (uint32_t) sigSize);

    //Если адрес метода -1, значит в методе нет кода, выход из функции
    if (*mAddr == -1)
        return;

    //Тут находится механика взятия аргументов по сигнатуре методов. Это перспективная механика
    //поэтому код ниже закомментирован
    //int8_t * args = NULL;
    //int8_t argsCount = INTERPRETATIR_GetMethodArgs(sig, args);

    //Тут должна быть механника взятия аргументов с OS текущего фрейма для последующего размещения
    //их на OS порождаемого фрейма, но покольку это перспективная механика, тут сейчас ничего не
    //происходит

    free(sig);

    //Тут нужно взять с OS aref. Дальше проверить, если они отличиается от
    //aref текущего фрейма !!! aref хранится во фрейме  а не в интерпретаторе !!!
    //и если они различны, то : То это перспективная механика и она требует
    //дальнейшей реализации. Если же они одентичны, то:

    //Создать новый фрейм и инициализировать его окружением для выполнения целевого метода
    //текущего инстанса
    Frame *frame = (Frame*) malloc(sizeof(Frame));
    frame->cRef = currentFrame->cRef;
    frame->aRef = currentFrame->aRef;
    frame->cia = (uint32_t *) mAddr;

    //Инициализировать интерпретатор новым фреймом
    currentFrame = frame;

    //Установить процессинговый флаг выхода из текушего блока интерпретации
    //(интерпретатор запуска препроцессор. Если функция инерпретациии сталкивается
    // со специальным флагом, она завершает свою работа и отает управление перпроцессору
    // который тут же стартует ее по новой. Это необходимо для дублирования виртуального
    // стека, аппаратным стеком вызовов функции интепретатора.)
    pStop = TRUE;

    //Завершить работу метода
}

void INTERPRETATOR_Set_Current_Frame(Frame *frame) {
    currentFrame = frame;
}

Frame* INTERPRETATOR_Get_Current_Frame() {
    return currentFrame;
}